---
alwaysApply: true
---

# API Standards - Python FastAPI & gRPC Design

## REST API with FastAPI

### HTTP Methods

| Method | Usage | Idempotent | Safe |
|--------|-------|------------|------|
| GET | Retrieve resource(s) | Yes | Yes |
| POST | Create resource | No | No |
| PUT | Replace resource | Yes | No |
| PATCH | Update resource partially | No | No |
| DELETE | Delete resource | Yes | No |

### FastAPI Route Implementation

```python
from fastapi import APIRouter, HTTPException, status, Depends
from typing import List, Optional
from uuid import UUID

router = APIRouter(prefix="/api/v1", tags=["robots"])

# ✅ Correct usage
@router.get("/robots", response_model=List[RobotResponse])
async def list_robots(
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    service: RobotService = Depends(get_robot_service)
) -> List[RobotResponse]:
    """List all robots with pagination."""
    return await service.list_robots(limit=limit, offset=offset)

@router.get("/robots/{robot_id}", response_model=RobotResponse)
async def get_robot(
    robot_id: UUID,
    service: RobotService = Depends(get_robot_service)
) -> RobotResponse:
    """Get specific robot by ID."""
    robot = await service.get_robot(robot_id)
    if not robot:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Robot not found"
        )
    return robot

@router.post("/robots", response_model=RobotResponse, status_code=status.HTTP_201_CREATED)
async def create_robot(
    robot: CreateRobotRequest,
    service: RobotService = Depends(get_robot_service)
) -> RobotResponse:
    """Create new robot."""
    return await service.create_robot(robot)

# ❌ Incorrect usage - avoid
# GET    /api/robots/create       # Don't use GET for actions
# POST   /api/robots/get          # Don't use POST for retrieval
# GET    /api/deleteRobot/{id}    # Don't encode action in URL
```

## HTTP Status Codes

### Success Codes (2xx)

```python
from fastapi import Response

# 200 OK - Standard success response
@router.get("/robots/{robot_id}")
async def get_robot(robot_id: UUID) -> RobotResponse:
    return robot  # FastAPI returns 200 by default

# 201 Created - Resource created successfully
@router.post("/robots", status_code=status.HTTP_201_CREATED)
async def create_robot(robot: CreateRobotRequest) -> RobotResponse:
    return created_robot

# 204 No Content - Successful deletion
@router.delete("/robots/{robot_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_robot(robot_id: UUID) -> None:
    await service.delete_robot(robot_id)
    return  # Returns 204 with empty body
```

### Client Error Codes (4xx)

```python
from fastapi import HTTPException
from pydantic import BaseModel
from datetime import datetime

class ErrorResponse(BaseModel):
    error: ErrorDetail
    timestamp: datetime = Field(default_factory=datetime.utcnow)

class ErrorDetail(BaseModel):
    code: str
    message: str
    details: Optional[dict] = None

# 400 Bad Request - Invalid input
@router.post("/robots")
async def create_robot(robot: CreateRobotRequest):
    if not is_valid_model(robot.model):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={
                "code": "VALIDATION_ERROR",
                "message": "Invalid robot model",
                "details": {"model": robot.model}
            }
        )

# 401 Unauthorized - Authentication required/failed
@router.get("/robots", dependencies=[Depends(verify_token)])
async def list_robots():
    pass  # verify_token raises 401 if auth fails

# 403 Forbidden - Insufficient permissions
@router.delete("/robots/{robot_id}")
async def delete_robot(
    robot_id: UUID,
    current_user: User = Depends(get_current_user)
):
    if not has_permission(current_user, "robots:delete"):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail={
                "code": "FORBIDDEN",
                "message": "Insufficient permissions"
            }
        )

# 404 Not Found - Resource does not exist
@router.get("/robots/{robot_id}")
async def get_robot(robot_id: UUID):
    robot = await service.get_robot(robot_id)
    if not robot:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail={
                "code": "NOT_FOUND",
                "message": "Robot not found",
                "details": {"robot_id": str(robot_id)}
            }
        )

# 409 Conflict - Resource already exists
@router.post("/robots")
async def create_robot(robot: CreateRobotRequest):
    if await service.robot_exists(robot.serial_number):
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail={
                "code": "CONFLICT",
                "message": "Robot already exists",
                "details": {"serial_number": robot.serial_number}
            }
        )

# 429 Too Many Requests - Rate limit exceeded
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@router.get("/robots")
@limiter.limit("100/minute")
async def list_robots(request: Request):
    pass  # slowapi handles 429 responses
```

### Server Error Codes (5xx)

```python
import logging

logger = logging.getLogger(__name__)

# 500 Internal Server Error - Unexpected error
@router.get("/robots")
async def list_robots():
    try:
        return await service.list_robots()
    except Exception as e:
        logger.error(f"Internal error: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={
                "code": "INTERNAL_ERROR",
                "message": "An unexpected error occurred"
            }
        )

# 503 Service Unavailable - External dependency down
@router.get("/robots/{robot_id}/status")
async def get_robot_status(robot_id: UUID):
    if not await check_external_service_health():
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail={
                "code": "UPSTREAM_UNAVAILABLE",
                "message": "External service temporarily unavailable",
                "details": {"retry_after": 30}
            }
        )
```

## Request/Response Models

### Pydantic Models for Validation

```python
from pydantic import BaseModel, Field, EmailStr, validator
from typing import Optional, List
from datetime import datetime
from uuid import UUID
from enum import Enum

class RobotModel(str, Enum):
    CC1 = "CC1"
    SH1 = "SH1"
    BELLA = "BELLA"

class RobotStatus(str, Enum):
    ONLINE = "online"
    OFFLINE = "offline"
    ERROR = "error"
    MAINTENANCE = "maintenance"

# Request Models
class CreateRobotRequest(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)
    model: RobotModel
    facility_id: UUID
    serial_number: str = Field(..., regex=r'^[A-Z0-9]{10}$')

    @validator('name')
    def validate_name(cls, v):
        """Ensure name doesn't contain special characters."""
        if not v.replace(' ', '').isalnum():
            raise ValueError('Name must be alphanumeric')
        return v.strip()

class UpdateRobotRequest(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    status: Optional[RobotStatus] = None
    facility_id: Optional[UUID] = None

# Response Models
class RobotResponse(BaseModel):
    id: UUID
    name: str
    model: RobotModel
    status: RobotStatus
    facility_id: UUID
    serial_number: str
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # For ORM compatibility

class PaginatedResponse(BaseModel):
    items: List[RobotResponse]
    total: int
    limit: int
    offset: int
    has_more: bool

# Error Response
class ErrorResponse(BaseModel):
    error: ErrorDetail
    timestamp: datetime = Field(default_factory=datetime.utcnow)

class ErrorDetail(BaseModel):
    code: str
    message: str
    details: Optional[dict] = None
```

## FastAPI Dependency Injection

```python
from fastapi import Depends
from typing import Optional

# Database session dependency
async def get_db() -> AsyncSession:
    async with async_session() as session:
        yield session

# Service dependencies
async def get_robot_service(
    db: AsyncSession = Depends(get_db)
) -> RobotService:
    return RobotService(db)

# Authentication dependencies
async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    user = await db.get(User, user_id)
    if user is None:
        raise credentials_exception
    return user

# Permission checking
def require_permission(permission: str):
    async def permission_checker(
        current_user: User = Depends(get_current_user)
    ):
        if not has_permission(current_user, permission):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Insufficient permissions"
            )
        return current_user
    return permission_checker
```

## Pagination

```python
from fastapi import Query

class PaginationParams:
    def __init__(
        self,
        limit: int = Query(20, ge=1, le=100, description="Items per page"),
        offset: int = Query(0, ge=0, description="Number of items to skip")
    ):
        self.limit = limit
        self.offset = offset

@router.get("/robots", response_model=PaginatedResponse)
async def list_robots(
    pagination: PaginationParams = Depends(),
    status: Optional[RobotStatus] = Query(None),
    service: RobotService = Depends(get_robot_service)
) -> PaginatedResponse:
    robots, total = await service.list_robots(
        limit=pagination.limit,
        offset=pagination.offset,
        status=status
    )

    return PaginatedResponse(
        items=robots,
        total=total,
        limit=pagination.limit,
        offset=pagination.offset,
        has_more=(pagination.offset + pagination.limit) < total
    )
```

## gRPC API Standards

### Protocol Buffer Design

```protobuf
syntax = "proto3";

package robot.v1;

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

// Service definition
service RobotService {
  rpc GetRobot(GetRobotRequest) returns (GetRobotResponse);
  rpc ListRobots(ListRobotsRequest) returns (ListRobotsResponse);
  rpc CreateRobot(CreateRobotRequest) returns (Robot);
  rpc UpdateRobot(UpdateRobotRequest) returns (Robot);
  rpc DeleteRobot(DeleteRobotRequest) returns (google.protobuf.Empty);

  // Streaming
  rpc StreamRobotStatus(StreamRobotStatusRequest) returns (stream RobotStatus);
}

// Messages
message Robot {
  string id = 1;
  string name = 2;
  string model = 3;
  string status = 4;
  string facility_id = 5;
  google.protobuf.Timestamp created_at = 6;
}

message GetRobotRequest {
  string robot_id = 1;
}

message GetRobotResponse {
  Robot robot = 1;
}
```

### gRPC Service Implementation

```python
import grpc
from grpc import aio
from proto import robot_pb2, robot_pb2_grpc

class RobotServicer(robot_pb2_grpc.RobotServiceServicer):
    def __init__(self, service: RobotService):
        self.service = service

    async def GetRobot(
        self,
        request: robot_pb2.GetRobotRequest,
        context: grpc.aio.ServicerContext
    ) -> robot_pb2.GetRobotResponse:
        """Get robot by ID."""
        try:
            robot = await self.service.get_robot(request.robot_id)
            if not robot:
                await context.abort(
                    grpc.StatusCode.NOT_FOUND,
                    f"Robot {request.robot_id} not found"
                )
            return robot_pb2.GetRobotResponse(
                robot=self._to_proto(robot)
            )
        except Exception as e:
            await context.abort(
                grpc.StatusCode.INTERNAL,
                f"Internal error: {str(e)}"
            )

    def _to_proto(self, robot: RobotModel) -> robot_pb2.Robot:
        """Convert domain model to proto."""
        return robot_pb2.Robot(
            id=str(robot.id),
            name=robot.name,
            model=robot.model,
            status=robot.status
        )
```

## Error Handling

### Custom Exception Handler

```python
from fastapi import Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": {
                "code": "VALIDATION_ERROR",
                "message": "Invalid request data",
                "details": exc.errors()
            },
            "timestamp": datetime.utcnow().isoformat()
        }
    )

@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request: Request, exc: StarletteHTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": {
                "code": "HTTP_ERROR",
                "message": exc.detail
            },
            "timestamp": datetime.utcnow().isoformat()
        }
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": {
                "code": "INTERNAL_ERROR",
                "message": "An internal error occurred"
            },
            "timestamp": datetime.utcnow().isoformat()
        }
    )
```

## Middleware

### CORS Configuration

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://app.example.com"],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH"],
    allow_headers=["Authorization", "Content-Type"],
    expose_headers=["X-Total-Count", "X-RateLimit-Limit"],
    max_age=3600
)
```

### Request ID Middleware

```python
from starlette.middleware.base import BaseHTTPMiddleware
import uuid

class RequestIDMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        response = await call_next(request)
        response.headers["X-Request-ID"] = request_id
        return response

app.add_middleware(RequestIDMiddleware)
```

## Rate Limiting

```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(
    key_func=get_remote_address,
    default_limits=["100/minute"],
    storage_uri="redis://localhost:6379"
)

app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@router.get("/robots")
@limiter.limit("10/minute")
async def list_robots(request: Request):
    pass
```

## Caching

```python
from fastapi_cache import FastAPICache
from fastapi_cache.decorator import cache
from fastapi_cache.backends.redis import RedisBackend

# Initialize cache
@app.on_event("startup")
async def startup():
    redis = aioredis.from_url("redis://localhost:6379")
    FastAPICache.init(RedisBackend(redis), prefix="fastapi-cache")

# Use cache decorator
@router.get("/robots/{robot_id}")
@cache(expire=60)  # Cache for 60 seconds
async def get_robot(robot_id: UUID):
    return await service.get_robot(robot_id)
```

## Health Checks

```python
@router.get("/health/live", tags=["health"])
async def liveness():
    """Liveness probe - is the service running?"""
    return {"status": "alive"}

@router.get("/health/ready", tags=["health"])
async def readiness(
    db: AsyncSession = Depends(get_db)
):
    """Readiness probe - can the service handle requests?"""
    try:
        # Check database
        await db.execute("SELECT 1")

        # Check Redis
        await redis.ping()

        # Check gRPC
        await check_grpc_health()

        return {"status": "ready"}
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Service not ready"
        )
```

## API Documentation

### OpenAPI/Swagger

```python
from fastapi import FastAPI

app = FastAPI(
    title="Robot Service API",
    description="Microservice for robot management",
    version="1.0.0",
    docs_url="/api/docs",
    redoc_url="/api/redoc",
    openapi_url="/api/openapi.json"
)

# Custom OpenAPI schema
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema

    openapi_schema = get_openapi(
        title="Robot Service API",
        version="1.0.0",
        description="API for managing robots",
        routes=app.routes,
    )

    # Add security schemes
    openapi_schema["components"]["securitySchemes"] = {
        "Bearer": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
        }
    }

    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi
```

## API Best Practices

### ✅ DO

- Use Pydantic for all validation
- Use dependency injection for services
- Use async/await for all I/O operations
- Include comprehensive error handling
- Version your APIs (/api/v1/)
- Document with OpenAPI/Swagger
- Implement health checks
- Use proper HTTP status codes
- Add request IDs for tracing
- Implement rate limiting
- Use connection pooling

### ❌ DON'T

- Use synchronous I/O in async handlers
- Return raw exceptions to clients
- Skip input validation
- Use global state
- Mix business logic with API layer
- Ignore security headers
- Return large unfiltered datasets
- Use print() instead of logging
- Skip error handling